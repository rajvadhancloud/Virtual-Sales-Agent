import { isValidElement } from "react";
import { desktopChunkSize, minChunkSize, mobileChunkSize, sanitizeRegex, specialSymbol, symbolMapping, utterancePropertiesAndEvents } from "./constants.js";
import { setState } from "./state.js";
export function ArrayToText(element) {
    if (typeof element === "string")
        return element;
    return element.map(ArrayToText).join(" ") + " ";
}
export function JSXToArray(element) {
    if (isValidElement(element)) {
        const { children } = element.props;
        if (Array.isArray(children))
            return children.map(JSXToArray);
        return JSXToArray(children);
    }
    return typeof element === "string" ? element : typeof element === "number" ? String(element) : "";
}
export function TextToChunks(text, size) {
    size = size ? Math.max(size, minChunkSize) : isMobile() ? mobileChunkSize : desktopChunkSize;
    const length = text.length;
    const result = [];
    let startIndex = 0;
    while (startIndex < length) {
        let endIndex = Math.min(startIndex + size, length);
        if (endIndex < length && text[endIndex] !== " ") {
            const spaceIndex = text.lastIndexOf(" ", endIndex);
            if (spaceIndex > startIndex)
                endIndex = spaceIndex;
        }
        result.push(text.slice(startIndex, endIndex));
        startIndex = endIndex;
    }
    return result;
}
export function cancel() {
    var _a;
    if (typeof window === "undefined")
        return;
    setState({ stopReason: "manual" });
    (_a = window.speechSynthesis) === null || _a === void 0 ? void 0 : _a.cancel();
}
export function cloneUtterance(utterance, text) {
    const newUtterance = new SpeechSynthesisUtterance(text);
    utterancePropertiesAndEvents.forEach((property) => (newUtterance[property] = utterance[property]));
    return newUtterance;
}
export function findCharIndex(words, index) {
    let currentIndex = 0;
    function recursiveSearch(stringArray, parentIndex = "") {
        if (typeof stringArray === "string") {
            const elementIndex = index - currentIndex;
            return (currentIndex += stringArray.length + 1) > index ? getIndex(parentIndex, elementIndex) : "";
        }
        for (let i = 0; i < stringArray.length; i++) {
            const element = stringArray[i];
            const result = recursiveSearch(element, i);
            if (result)
                return getIndex(parentIndex, result);
        }
        currentIndex++;
        return "";
    }
    return recursiveSearch(words);
}
export const getIndex = (parentIndex, index) => `${parentIndex === "" ? "" : parentIndex + "-"}${index}`;
export function isMobile(iOS = true) {
    var _a;
    let result = (_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.mobile;
    result !== null && result !== void 0 ? result : (result = /Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (iOS && /iPhone|iPad|iPod/i.test(navigator.userAgent)));
    return result;
}
export function isParent(parentIndex, index) {
    if (!(index === null || index === void 0 ? void 0 : index.startsWith(parentIndex)))
        return false;
    if (parentIndex) {
        const indexParts = index.split("-");
        const parentIndexParts = parentIndex.split("-");
        for (let i = 0; i < parentIndexParts.length; i++) {
            if (indexParts[i] !== parentIndexParts[i])
                return false;
        }
    }
    return true;
}
export const sanitize = (text) => text.replace(sanitizeRegex, (match, group) => (group ? group + ")" : ` ${symbolMapping[match]}${specialSymbol}`));
