import { cancel } from "./utils.js";
const queue = [];
const queueListeners = [];
export function clearQueue(cancelSpeech = false, start = 0, emitEvent = false) {
    if (cancelSpeech)
        cancel();
    queue.slice(start).forEach(({ setSpeechStatus }) => setSpeechStatus("stopped"));
    queue.length = 0;
    if (emitEvent)
        emit();
}
export function addToQueue(item, callback) {
    queue.push(item);
    emit(callback);
}
export const clearQueueHook = () => clearQueue(true, 1, true);
export const clearQueueUnload = () => clearQueue(true, 1);
export function dequeue(index = 0) {
    if (index === 0)
        cancel();
    else
        removeFromQueue(index);
}
export function emit(callback) {
    const utteranceQueue = queue.map(({ displayUtterance }) => displayUtterance);
    queueListeners.forEach((listener) => listener(utteranceQueue));
    callback === null || callback === void 0 ? void 0 : callback(utteranceQueue);
}
export function removeFromQueue(utterance, callback) {
    const index = typeof utterance === "number" ? utterance : queue.findIndex((item) => item.utterance === utterance);
    if (index === -1)
        return;
    const [item] = queue.splice(index, 1);
    if (item) {
        if (index === 0)
            cancel();
        else
            item.setSpeechStatus("stopped");
        emit(callback);
    }
}
export function speakFromQueue() {
    const item = queue[0];
    if (item)
        window.speechSynthesis.speak(item.utterance);
}
export function subscribe(callback) {
    queueListeners.push(callback);
    return () => {
        const index = queueListeners.indexOf(callback);
        if (index !== -1)
            queueListeners.splice(index, 1);
    };
}
